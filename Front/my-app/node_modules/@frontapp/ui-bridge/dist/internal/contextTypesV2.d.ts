import { ApplicationCancelToken } from './asyncTypesV2';
import { ApplicationChannelList } from './channelTypesV2';
import { ApplicationCommentList } from './commentTypesV2';
import { ApplicationConversation, ApplicationConversationStatus, ApplicationSingleConversation } from './conversationTypesV2';
import { ApplicationDraft, ApplicationDraftTemplate, ApplicationDraftUpdate } from './draftTypesV2';
import { EntryPointTypesEnum } from './entryPointTypesV2';
import { HttpRequest, HttpResponse } from './httpTypesV2';
import { ApplicationAttachmentId, ApplicationCommentId, ApplicationConversationId, ApplicationDraftId, ApplicationInboxId, ApplicationMessageId, ApplicationTagId, ApplicationTeammateId, ApplicationTopicId } from './idTypesV2';
import { ApplicationInboxList } from './inboxTypesV2';
import { ApplicationLink } from './linkTypesV2';
import { ApplicationMessageList } from './messageTypesV2';
import { ApplicationPaginationToken } from './paginationTypesV2';
import { ApplicationRecipientList } from './recipientTypesV2';
import { HttpRelayRequest } from './relayTypesV2';
import { ApplicationTagList } from './tagTypesV2';
import { ApplicationTeammate, ApplicationTeammateList } from './teammateTypesV2';
import { ApplicationTopic } from './topicTypesV2';
import { Widget, WidgetTemplate } from './widgetTypesV2';
export declare enum ApplicationAuthenticationStatusesEnum {
    AUTHORIZED = "authorized"
}
export interface ApplicationContextBase {
    /** Unique ID for this context. */
    id: string;
    /** Unique ID of the Entry Point this context was created from. */
    entryPointId: string;
    /** Unique ID of the component that hosts this entry point. */
    hostId: string;
    /** List of function names supported by this context object with their arity. */
    functionArities: {
        [K: string]: number;
    };
    /** Current teammate's preferences for this application. */
    preferences: object;
    /** Current teammate's authentication. */
    authentication: {
        status?: ApplicationAuthenticationStatusesEnum;
    };
    /** Current teammate. */
    teammate: ApplicationTeammate;
    /**
     * Create a new Widget for the current context.
     * @param template Definition of the Widget to create.
     * @param cancelToken Cancel the creation of the Widget.
     * @returns Newly created Widget.
     */
    createWidget(template: WidgetTemplate, cancelToken?: ApplicationCancelToken): Promise<Widget>;
    /**
     * Destroy an existing Widget.
     * @param widgetId ID of the Widget to destroy.
     * @param cancelToken Cancel the Widget destruction.
     */
    destroyWidget(widgetId: string, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Send an HTTP request to the private API of the application.
     * @param request Definition of the HTTP request to run.
     * @param cancelToken Cancel the HTTP request.
     * @returns HTTP response.
     */
    sendHttp(request: HttpRequest, cancelToken?: ApplicationCancelToken): Promise<HttpResponse>;
    /**
     * Relay an HTTP request.
     * @param request Definition of the HTTP request to run.
     * @param cancelToken Cancel the HTTP request.
     * @returns HTTP response.
     */
    relayHttp(request: HttpRelayRequest, cancelToken?: ApplicationCancelToken): Promise<HttpResponse>;
    /**
     * Start the authentication flow according to the configured security scheme.
     */
    authenticate(cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Delete the credentials stored for the current teammate.
     */
    deauthenticate(cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Open a browser window.
     * @param url URL to navigate to.
     */
    openUrl(url: string, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Open a browser popup.
     * @param url URL to open.
     * @param options Optional object to define the properties of the popup.
     */
    openUrlInPopup(url: string, options: {
        width?: number;
        height?: number;
    } | undefined, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Open a conversation in a popup.
     * @param conversationId Conversation to open.
     * @param cancelToken Cancel the request.
     */
    openConversationInPopup(conversationId: ApplicationConversationId, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Perform a search in Front for the current teammate.
     * @param query Search query.
     * @param cancelToken Cancel the search request.
     */
    search(query: string, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * List the teammates of the company.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of teammates.
     */
    listTeammates(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationTeammateList>;
    /**
     * List the inboxes accessible by the current teammate.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of inboxes.
     */
    listInboxes(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationInboxList>;
    /**
     * List the channels accessible by the current teammate.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of channels.
     */
    listChannels(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationChannelList>;
    /**
     * List the tags accessible by the current teammate.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of tags.
     */
    listTags(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationTagList>;
    /**
     * Create a draft.
     * @param template Properties of the draft to create
     * @param cancelToken Cancel the request.
     * @returns The newly created draft.
     */
    createDraft(template: ApplicationDraftTemplate, cancelToken?: ApplicationCancelToken): Promise<ApplicationDraft>;
    /**
     * Update a draft.
     * @param draftId ID of the draft to update.
     * @param update Properties of the draft to update.
     * @param cancelToken Cancel the request.
     */
    updateDraft(draftId: ApplicationDraftId, update: ApplicationDraftUpdate, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Fetch the current path the user is in within the app.
     * If the user is composing a new message in a popped out composer,
     *     noConversationPopoverContext,
     * we will return a constant string of 'composing-new'.
     * @param cancelToken Cancel the request.
     */
    fetchPath(cancelToken?: ApplicationCancelToken): Promise<string>;
}
export interface NoConversationContext extends ApplicationContextBase {
    type: 'noConversation';
}
export interface ExistingConversationBaseContext extends ApplicationContextBase {
    /**
     * Add a topic to the selected conversations.
     * @param externalUrl URL of the topic.
     * @param name Human readable name.
     * @param cancelToken Cancel the creation of the link.
     * @returns The added topic.
     * @deprecated
     */
    addTopic(externalUrl: string, name: string | undefined, cancelToken?: ApplicationCancelToken): Promise<ApplicationTopic>;
    /**
     * Add a link to the selected conversations.
     * @param externalUrl URL of the topic.
     * @param name Human readable name.
     * @param cancelToken Cancel the creation of the link.
     * @returns The added link.
     */
    addLink(externalUrl: string, name: string | undefined, cancelToken?: ApplicationCancelToken): Promise<ApplicationLink>;
    /**
     * Assign or unassign the selected conversations.
     * @param teammateId ID of the teammate to assign the conversations to. If null, the conversations will be unassigned.
     * @param cancelToken Cancel the request.
     */
    assign(teammateId: ApplicationTeammateId | null, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Move the selected conversations to an inbox.
     * @param inboxId ID of the inbox.
     * @param cancelToken Cancel the request.
     */
    move(inboxId: ApplicationInboxId, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Set the status of the selected conversations.
     * @param status Conversation status to apply.
     * @param cancelToken Cancel the request.
     */
    setStatus(status: ApplicationConversationStatus, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Add the specified tags to the selected conversations.
     * @param tagIds Tag IDs to add.
     * @param cancelToken Cancel the request.
     */
    tag(tagIds: ReadonlyArray<ApplicationTagId>, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Remove the specified tags from the selected conversations.
     * @param tagIds Tag IDs to remove.
     * @param cancelToken Cancel the request.
     */
    untag(tagIds: ReadonlyArray<ApplicationTagId>, cancelToken?: ApplicationCancelToken): Promise<void>;
    /**
     * Remove the specified link from the conversation.
     * @param linkId Link ID to remove.
     * @param cancelToken Cancel the request.
     */
    removeLink(linkId: ApplicationTopicId, cancelToken?: ApplicationCancelToken): Promise<void>;
}
export interface SingleConversationContext extends ExistingConversationBaseContext {
    type: 'singleConversation';
    /** The selected conversation. */
    conversation: ApplicationSingleConversation;
    /**
     * Fetch a draft by ID.
     * @param draftId ID of the draft to fetch.
     * @param cancelToken Cancel the request.
     * @returns The draft, if found.
     */
    fetchDraft(draftId: ApplicationDraftId, cancelToken?: ApplicationCancelToken): Promise<ApplicationDraft | undefined>;
    /**
     * List the messages in the current conversation.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of messages.
     */
    listMessages(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationMessageList>;
    /**
     * List the comments in the current conversation.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of comments.
     */
    listComments(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationCommentList>;
    /**
     * Download the specified attachment that is attached to a message. To get attachments you will need to use
     * {@link listMessages} which returns messages with any attachments.
     * @param messageOrCommentId Message or comment id for the attachment.
     * @param attachmentId Attachment id to be fetched.
     * @param cancelToken Cancel the request.
     * @returns File holding the data of the attachment
     */
    downloadAttachment(messageOrCommentId: ApplicationMessageId | ApplicationCommentId, attachmentId: ApplicationAttachmentId, cancelToken?: ApplicationCancelToken): Promise<File | undefined>;
    /**
     * List the recipients in the current conversation in the order in which the messages are sent.
     * @param paginationToken Token of the requested page. If omitted, will return the first page of results.
     * @param cancelToken Cancel the request.
     * @returns List of recipients.
     */
    listRecipients(paginationToken?: ApplicationPaginationToken, cancelToken?: ApplicationCancelToken): Promise<ApplicationRecipientList>;
}
export interface NoConversationPopoverContext extends ApplicationContextBase, Pick<SingleConversationContext, 'fetchDraft'> {
    type: 'noConversationPopover';
    draftId?: ApplicationDraftId;
    /**
     * Closes the popover.
     * * @param cancelToken Cancel the request.
     */
    requestClose(cancelToken?: ApplicationCancelToken): Promise<void>;
}
export interface SingleConversationPopoverContext extends Omit<SingleConversationContext, 'type'> {
    type: 'singleConversationPopover';
    /**
     * Closes the popover.
     * * @param cancelToken Cancel the request.
     */
    requestClose(cancelToken?: ApplicationCancelToken): Promise<void>;
}
export interface MultiConversationsContext extends ExistingConversationBaseContext {
    type: 'multiConversations';
    /** Selected conversations */
    conversations: ReadonlyArray<ApplicationConversation>;
}
export declare type ExistingConversationContext = SingleConversationContext | MultiConversationsContext;
export declare type ConversationContext = NoConversationContext | NoConversationPopoverContext | SingleConversationContext | SingleConversationPopoverContext | MultiConversationsContext;
export interface MessageContext extends ApplicationContextBase {
    type: 'message';
    messageId: string;
}
export declare type ApplicationContext = ConversationContext | MessageContext;
interface ContextMap {
    [EntryPointTypesEnum.CONVERSATION_LINK_DROPDOWN]: ExistingConversationContext;
    [EntryPointTypesEnum.MESSAGE_MORE_DROPDOWN]: MessageContext;
    [EntryPointTypesEnum.SIDE_PANEL]: ConversationContext;
}
export declare type ContextOf<T extends keyof ContextMap> = ContextMap[T];
export {};
